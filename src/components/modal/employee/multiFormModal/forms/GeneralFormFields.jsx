import React, { useState, useEffect } from "react";
import { Controller, useFormContext } from "react-hook-form";
import {
  TextField,
  MenuItem,
  Select,
  FormControl,
  InputLabel,
  Box,
  FormHelperText,
  Autocomplete,
  InputAdornment,
  CircularProgress,
  Switch,
  FormControlLabel,
  Tooltip,
} from "@mui/material";
import ImageUploadField from "./ImageUploadField";

const GeneralFormFields = ({
  control,
  errors,
  mode,
  isFieldDisabled,
  isReadOnly,
  religions,
  prefixes,
  referrers,
  approvalForms,
  nationalities,
  religionsLoading,
  prefixesLoading,
  generalsLoading,
  approvalFormsLoading,
  nationalitiesLoading,
  nextIdLoading,
  uniqueCheckLoading,
  handleDropdownFocus,
  dispatch,
  setApprovalForm,
  watch,
  initialData,
  setValue,
  getNextId,
  validateIdUniqueness,
}) => {
  const { clearErrors } = useFormContext();
  const [isManualIdEntry, setIsManualIdEntry] = useState(false);
  const [autoGeneratedId, setAutoGeneratedId] = useState("");

  const civilStatusOptions = [
    "SINGLE",
    "MARRIED",
    "WIDOWED",
    "DIVORCED",
    "SEPARATED",
    "REGISTERED PARTNERSHIP",
  ];
  const genderOptions = ["MALE", "FEMALE"];

  const watchedPrefix = watch("prefix");
  const watchedIdNumber = watch("id_number");

  useEffect(() => {
    let timeoutId;

    if (mode !== "create") {
      return;
    }

    if (
      isManualIdEntry &&
      watchedPrefix?.id &&
      watchedIdNumber &&
      mode === "create"
    ) {
      timeoutId = setTimeout(() => {
        validateIdUniqueness(watchedPrefix.id, watchedIdNumber);
      }, 500);
    }

    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [
    watchedPrefix,
    watchedIdNumber,
    isManualIdEntry,
    mode,
    validateIdUniqueness,
  ]);

  useEffect(() => {
    if (
      mode === "create" &&
      !isManualIdEntry &&
      watchedIdNumber &&
      autoGeneratedId
    ) {
      clearErrors("id_number");
    }
  }, [watchedIdNumber, isManualIdEntry, autoGeneratedId, mode, clearErrors]);

  const getMaxBirthDate = () => {
    const today = new Date();
    const eighteenYearsAgo = new Date(
      today.getFullYear() - 18,
      today.getMonth(),
      today.getDate()
    );
    return eighteenYearsAgo.toISOString().split("T")[0];
  };

  const handlePrefixChange = async (item) => {
    if (!isReadOnly && item && item.id && mode === "create") {
      try {
        const result = await getNextId(item.id);
        if (result.data && result.data.next_id_number) {
          const generatedId = result.data.next_id_number;
          setAutoGeneratedId(generatedId);
          if (!isManualIdEntry) {
            setValue("id_number", generatedId, { shouldValidate: true });
            clearErrors("id_number");
          }
        }
      } catch (error) {
        setAutoGeneratedId("");
        if (!isManualIdEntry) {
          setValue("id_number", "");
        }
      }
    }
  };

  const handleManualIdToggle = (checked) => {
    setIsManualIdEntry(checked);
    if (!checked) {
      setValue("id_number", autoGeneratedId, { shouldValidate: true });
      if (autoGeneratedId) {
        clearErrors("id_number");
      }
    } else {
      setValue("id_number", "", { shouldValidate: false });
    }
  };

  const handleIdNumberChange = (e) => {
    const value = e.target.value;
    const numericValue = value.replace(/[^0-9]/g, "");
    e.target.value = numericValue;
    return numericValue;
  };

  return (
    <Box sx={{ px: 2 }}>
      <Box
        sx={{
          display: "grid",
          gridTemplateColumns: {
            xs: "1fr",
            sm: "1fr",
            md: "repeat(2, 1fr)",
          },
          "@media (min-width: 750px)": {
            gridTemplateColumns: "repeat(2, 1fr)",
          },
          gap: 2,
        }}>
        {mode === "create" && (
          <Box sx={{ gridColumn: "1 / -1" }}>
            <Controller
              name="submission_title"
              control={control}
              render={({ field: { onChange, value } }) => {
                const safeApprovalForms = Array.isArray(approvalForms)
                  ? approvalForms.filter(
                      (item) => item && typeof item === "object"
                    )
                  : [];

                return (
                  <FormControl
                    fullWidth
                    variant="outlined"
                    error={!!errors.submission_title}
                    disabled={isFieldDisabled || approvalFormsLoading}>
                    <Autocomplete
                      onChange={(event, item) => {
                        if (!isReadOnly) {
                          onChange(item || null);
                          if (item && typeof item === "object") {
                            dispatch(setApprovalForm(item));
                          }
                        }
                      }}
                      value={value || null}
                      options={safeApprovalForms}
                      loading={approvalFormsLoading}
                      disabled={isFieldDisabled}
                      readOnly={isReadOnly}
                      onFocus={() => {
                        if (!isReadOnly) {
                          handleDropdownFocus("approvalForms");
                        }
                      }}
                      getOptionLabel={(item) => {
                        if (!item || typeof item !== "object") {
                          return "";
                        }

                        return (
                          item.submission_title ||
                          item.linked_mrf_title ||
                          item.title ||
                          item.name ||
                          ""
                        );
                      }}
                      isOptionEqualToValue={(option, value) => {
                        if (
                          !option ||
                          !value ||
                          typeof option !== "object" ||
                          typeof value !== "object"
                        ) {
                          return false;
                        }

                        const optionId =
                          option.id ||
                          option.submission_title ||
                          option.linked_mrf_title;
                        const valueId =
                          value.id ||
                          value.submission_title ||
                          value.linked_mrf_title;

                        const optionTitle =
                          option.submission_title ||
                          option.linked_mrf_title ||
                          option.title ||
                          option.name;
                        const valueTitle =
                          value.submission_title ||
                          value.linked_mrf_title ||
                          value.title ||
                          value.name;

                        const isEqual =
                          optionId === valueId || optionTitle === valueTitle;
                        return isEqual;
                      }}
                      renderOption={(props, option) => {
                        if (!option || typeof option !== "object") {
                          return null;
                        }

                        const label =
                          option.submission_title ||
                          option.linked_mrf_title ||
                          option.title ||
                          option.name ||
                          "";
                        return (
                          <li
                            {...props}
                            key={
                              option.id ||
                              option.submission_title ||
                              option.linked_mrf_title ||
                              Math.random().toString(36)
                            }
                            style={{
                              whiteSpace: "normal",
                              wordWrap: "break-word",
                            }}>
                            {label}
                          </li>
                        );
                      }}
                      onBlur={() => {
                        if (
                          !value ||
                          typeof value !== "object" ||
                          (!value.id &&
                            !value.submission_title &&
                            !value.linked_mrf_title)
                        ) {
                          onChange(null);
                        }
                      }}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          label="Form *"
                          error={!!errors.submission_title}
                          helperText={errors.submission_title?.message}
                          InputProps={{
                            ...params.InputProps,
                            readOnly: isReadOnly,
                          }}
                          placeholder={
                            approvalFormsLoading
                              ? "Loading..."
                              : "Select a form"
                          }
                        />
                      )}
                      noOptionsText="No forms found"
                      loadingText="Loading forms..."
                    />
                  </FormControl>
                );
              }}
            />
          </Box>
        )}

        {(mode === "edit" || mode === "view") && (
          <Box sx={{ gridColumn: "1 / -1" }}>
            <Controller
              name="submission_title"
              control={control}
              render={({ field }) => (
                <TextField
                  {...field}
                  value={
                    field.value ||
                    initialData?.general_info?.linked_mrf_title ||
                    initialData?.linked_mrf_title ||
                    ""
                  }
                  label={
                    <>
                      Form <span style={{ color: "red" }}>*</span>
                    </>
                  }
                  variant="outlined"
                  fullWidth
                  disabled={true}
                  error={!!errors.submission_title}
                  helperText={errors.submission_title?.message}
                  InputProps={{ readOnly: true }}
                />
              )}
            />
          </Box>
        )}

        <Box sx={{ gridColumn: "1 / -1" }}>
          <ImageUploadField
            control={control}
            errors={errors}
            mode={mode}
            isFieldDisabled={isFieldDisabled}
            isReadOnly={isReadOnly}
            watch={watch}
            setValue={setValue}
            initialData={initialData}
          />
        </Box>

        <Box>
          <Controller
            name="first_name"
            control={control}
            render={({ field }) => (
              <TextField
                {...field}
                label={
                  <>
                    First Name <span style={{ color: "red" }}>*</span>
                  </>
                }
                variant="outlined"
                fullWidth
                disabled={isFieldDisabled}
                error={!!errors.first_name}
                helperText={errors.first_name?.message}
                InputProps={{ readOnly: isReadOnly }}
              />
            )}
          />
        </Box>

        <Box>
          <Controller
            name="middle_name"
            control={control}
            render={({ field }) => (
              <TextField
                {...field}
                label="Middle Name (Optional)"
                variant="outlined"
                fullWidth
                disabled={isFieldDisabled}
                InputProps={{ readOnly: isReadOnly }}
              />
            )}
          />
        </Box>

        <Box>
          <Controller
            name="last_name"
            control={control}
            render={({ field }) => (
              <TextField
                {...field}
                label={
                  <>
                    Last Name <span style={{ color: "red" }}>*</span>
                  </>
                }
                variant="outlined"
                fullWidth
                disabled={isFieldDisabled}
                error={!!errors.last_name}
                helperText={errors.last_name?.message}
                InputProps={{ readOnly: isReadOnly }}
              />
            )}
          />
        </Box>

        <Box>
          <Controller
            name="suffix"
            control={control}
            render={({ field }) => (
              <TextField
                {...field}
                label="Suffix (Optional)"
                variant="outlined"
                fullWidth
                disabled={isFieldDisabled}
                InputProps={{ readOnly: isReadOnly }}
              />
            )}
          />
        </Box>

        <Box>
          <Controller
            name="prefix"
            control={control}
            render={({ field: { onChange, value } }) => (
              <FormControl
                fullWidth
                variant="outlined"
                error={!!errors.prefix}
                disabled={isFieldDisabled || prefixesLoading}>
                <Autocomplete
                  onChange={async (event, item) => {
                    if (!isReadOnly) {
                      onChange(item || null);
                      if (item) {
                        await handlePrefixChange(item);
                      } else {
                        setAutoGeneratedId("");
                        setValue("id_number", "");
                      }
                    }
                  }}
                  value={value || null}
                  options={prefixes ?? []}
                  loading={prefixesLoading}
                  disabled={isFieldDisabled}
                  readOnly={isReadOnly}
                  getOptionLabel={(item) =>
                    item?.name || item?.title || item?.label || item?.code || ""
                  }
                  isOptionEqualToValue={(option, value) => {
                    if (!option || !value) return false;
                    return option.id === value.id;
                  }}
                  onFocus={() => {
                    if (!isReadOnly) {
                      handleDropdownFocus("prefixes");
                    }
                  }}
                  onBlur={() => {
                    if (!value || !value.id) {
                      onChange(null);
                      setAutoGeneratedId("");
                      setValue("id_number", "");
                    }
                  }}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label={
                        <>
                          Prefix <span style={{ color: "red" }}>*</span>
                        </>
                      }
                      error={!!errors.prefix}
                      helperText={errors.prefix?.message}
                      InputProps={{
                        ...params.InputProps,
                        readOnly: isReadOnly,
                      }}
                    />
                  )}
                />
              </FormControl>
            )}
          />
        </Box>

        <Box>
          <Controller
            name="id_number"
            control={control}
            render={({ field: { onChange, value, ...rest } }) => (
              <TextField
                {...rest}
                value={value || ""}
                onChange={(e) => {
                  const numericValue = handleIdNumberChange(e);
                  onChange(numericValue);
                }}
                label={
                  <>
                    ID Number <span style={{ color: "red" }}>*</span>
                  </>
                }
                variant="outlined"
                fullWidth
                disabled={
                  isFieldDisabled ||
                  nextIdLoading ||
                  (!isManualIdEntry && mode === "create") ||
                  mode === "edit" ||
                  mode === "view"
                }
                error={!!errors.id_number}
                helperText={errors.id_number?.message}
                InputProps={{
                  readOnly: isReadOnly || mode === "edit",
                  endAdornment:
                    mode === "create" && !isReadOnly ? (
                      <InputAdornment position="end">
                        <Tooltip title="Toggle to manually enter ID number">
                          <FormControlLabel
                            control={
                              <Switch
                                checked={isManualIdEntry}
                                onChange={(e) =>
                                  handleManualIdToggle(e.target.checked)
                                }
                                size="small"
                                disabled={isFieldDisabled || nextIdLoading}
                                sx={{
                                  "& .MuiSwitch-switchBase": {
                                    color: "#ff4400",
                                    "&:hover": {
                                      backgroundColor: "rgba(255, 68, 0, 0.08)",
                                    },
                                  },
                                  "& .MuiSwitch-switchBase.Mui-checked": {
                                    color: "#ff4400",
                                    "&:hover": {
                                      backgroundColor: "rgba(255, 68, 0, 0.08)",
                                    },
                                  },
                                  "& .MuiSwitch-track": {
                                    backgroundColor: "#ff4400",
                                    opacity: 0.3,
                                  },
                                  "& .MuiSwitch-switchBase.Mui-checked + .MuiSwitch-track":
                                    {
                                      backgroundColor: "#ff4400",
                                      opacity: 1,
                                    },
                                }}
                              />
                            }
                            sx={{
                              m: 0,
                              "& .MuiFormControlLabel-label": {
                                fontSize: "0.75rem",
                              },
                            }}
                          />
                        </Tooltip>
                      </InputAdornment>
                    ) : (nextIdLoading && mode === "create") ||
                      (uniqueCheckLoading &&
                        isManualIdEntry &&
                        mode === "create") ? (
                      <InputAdornment position="end">
                        <CircularProgress
                          size={20}
                          sx={{
                            color: "#ff4400",
                          }}
                        />
                      </InputAdornment>
                    ) : null,
                }}
                placeholder={
                  mode === "edit" || mode === "view"
                    ? ""
                    : nextIdLoading
                    ? "Generating ID..."
                    : isManualIdEntry
                    ? "Enter ID manually"
                    : "Auto-generated ID"
                }
              />
            )}
          />
        </Box>

        <Box>
          <Controller
            name="birth_date"
            control={control}
            render={({ field }) => (
              <TextField
                {...field}
                label={
                  <>
                    Birth Date <span style={{ color: "red" }}>*</span>
                  </>
                }
                type="date"
                variant="outlined"
                fullWidth
                disabled={isFieldDisabled}
                error={!!errors.birth_date}
                helperText={errors.birth_date?.message}
                InputLabelProps={{ shrink: true }}
                InputProps={{ readOnly: isReadOnly }}
                inputProps={{ max: getMaxBirthDate() }}
              />
            )}
          />
        </Box>

        <Box>
          <Controller
            name="birth_place"
            control={control}
            render={({ field }) => (
              <TextField
                {...field}
                label={
                  <>
                    Birthplace <span style={{ color: "red" }}>*</span>
                  </>
                }
                variant="outlined"
                fullWidth
                disabled={isFieldDisabled}
                error={!!errors.birth_place}
                helperText={errors.birth_place?.message}
                InputProps={{ readOnly: isReadOnly }}
              />
            )}
          />
        </Box>

        <Box>
          <Controller
            name="nationality"
            control={control}
            render={({ field: { onChange, value } }) => (
              <FormControl
                fullWidth
                variant="outlined"
                error={!!errors.nationality}
                disabled={isFieldDisabled || nationalitiesLoading}>
                <Autocomplete
                  onChange={(event, item) => {
                    if (!isReadOnly) {
                      onChange(item || null);
                    }
                  }}
                  value={value || null}
                  options={nationalities ?? []}
                  loading={nationalitiesLoading}
                  disabled={isFieldDisabled}
                  readOnly={isReadOnly}
                  getOptionLabel={(item) => item?.name || ""}
                  isOptionEqualToValue={(option, value) => {
                    if (!option || !value) return false;
                    return option.id === value.id;
                  }}
                  onFocus={() => {
                    if (!isReadOnly) {
                      handleDropdownFocus("nationalities");
                    }
                  }}
                  onBlur={() => {
                    if (!value || !value.id) {
                      onChange(null);
                    }
                  }}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label={
                        <>
                          Nationality <span style={{ color: "red" }}>*</span>
                        </>
                      }
                      error={!!errors.nationality}
                      helperText={errors.nationality?.message}
                      InputProps={{
                        ...params.InputProps,
                        readOnly: isReadOnly,
                      }}
                    />
                  )}
                />
              </FormControl>
            )}
          />
        </Box>

        <Box>
          <Controller
            name="gender"
            control={control}
            render={({ field }) => (
              <FormControl
                fullWidth
                variant="outlined"
                error={!!errors.gender}
                disabled={isFieldDisabled}>
                <InputLabel>
                  Gender <span style={{ color: "red" }}>*</span>
                </InputLabel>
                <Select {...field} label="Gender *" readOnly={isReadOnly}>
                  <MenuItem value="">
                    <em>Select Gender</em>
                  </MenuItem>
                  {genderOptions.map((gender) => (
                    <MenuItem key={gender} value={gender}>
                      {gender}
                    </MenuItem>
                  ))}
                </Select>
                {errors.gender && (
                  <FormHelperText>{errors.gender.message}</FormHelperText>
                )}
              </FormControl>
            )}
          />
        </Box>

        <Box>
          <Controller
            name="civil_status"
            control={control}
            render={({ field }) => (
              <FormControl
                fullWidth
                variant="outlined"
                error={!!errors.civil_status}
                disabled={isFieldDisabled}>
                <InputLabel>
                  Civil Status <span style={{ color: "red" }}>*</span>
                </InputLabel>
                <Select {...field} label="Civil Status *" readOnly={isReadOnly}>
                  <MenuItem value="">
                    <em>Select Civil Status</em>
                  </MenuItem>
                  {civilStatusOptions.map((status) => (
                    <MenuItem key={status} value={status}>
                      {status}
                    </MenuItem>
                  ))}
                </Select>
                {errors.civil_status && (
                  <FormHelperText>{errors.civil_status.message}</FormHelperText>
                )}
              </FormControl>
            )}
          />
        </Box>

        <Box>
          <Controller
            name="religion"
            control={control}
            render={({ field: { onChange, value } }) => (
              <FormControl
                fullWidth
                variant="outlined"
                error={!!errors.religion}
                disabled={isFieldDisabled || religionsLoading}>
                <Autocomplete
                  onChange={(event, item) => {
                    if (!isReadOnly) {
                      onChange(item || null);
                    }
                  }}
                  value={value || null}
                  options={religions ?? []}
                  loading={religionsLoading}
                  disabled={isFieldDisabled}
                  readOnly={isReadOnly}
                  getOptionLabel={(item) => item?.name || ""}
                  isOptionEqualToValue={(option, value) => {
                    if (!option || !value) return false;
                    return option.id === value.id;
                  }}
                  onFocus={() => {
                    if (!isReadOnly) {
                      handleDropdownFocus("religions");
                    }
                  }}
                  onBlur={() => {
                    if (!value || !value.id) {
                      onChange(null);
                    }
                  }}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label={
                        <>
                          Religion <span style={{ color: "red" }}>*</span>
                        </>
                      }
                      error={!!errors.religion}
                      helperText={errors.religion?.message}
                      InputProps={{
                        ...params.InputProps,
                        readOnly: isReadOnly,
                      }}
                    />
                  )}
                />
              </FormControl>
            )}
          />
        </Box>

        <Box>
          <Controller
            name="referred_by"
            control={control}
            render={({ field: { onChange, value } }) => {
              return (
                <FormControl
                  fullWidth
                  variant="outlined"
                  disabled={isFieldDisabled || generalsLoading}>
                  <Autocomplete
                    onChange={(event, item) => {
                      if (!isReadOnly) {
                        onChange(item || null);
                      }
                    }}
                    value={value || null}
                    options={referrers ?? []}
                    loading={generalsLoading}
                    disabled={isFieldDisabled}
                    readOnly={isReadOnly}
                    getOptionLabel={(item) => {
                      const label =
                        item?.full_name ||
                        item?.name ||
                        `${item?.first_name || ""} ${
                          item?.last_name || ""
                        }`.trim() ||
                        item?.title ||
                        "";
                      return label;
                    }}
                    isOptionEqualToValue={(option, value) => {
                      if (!option || !value) return false;
                      const isEqual = option.id === value.id;
                      return isEqual;
                    }}
                    onFocus={() => {
                      if (!isReadOnly) {
                        handleDropdownFocus("referrers");
                      }
                    }}
                    onBlur={() => {
                      if (!value || !value.id) {
                        onChange(null);
                      }
                    }}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        label="Referred By (Optional)"
                        InputProps={{
                          ...params.InputProps,
                          readOnly: isReadOnly,
                        }}
                      />
                    )}
                  />
                </FormControl>
              );
            }}
          />
        </Box>

        <Box>
          <Controller
            name="remarks"
            control={control}
            render={({ field }) => (
              <TextField
                {...field}
                label="Remarks (Optional)"
                variant="outlined"
                fullWidth
                disabled={isFieldDisabled}
                placeholder="Additional notes or comments..."
                InputProps={{
                  readOnly: isReadOnly,
                }}
              />
            )}
          />
        </Box>
      </Box>
    </Box>
  );
};

GeneralFormFields.displayName = "GeneralFormFields";

export default GeneralFormFields;
